<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Distinct‐Slope Dot Grid</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }
    #controls {
      margin-bottom: 15px;
    }
    #gameCanvas {
      border: 1px solid #444;
      background-color: #fafafa;
      cursor: pointer;
    }
    #info {
      margin-top: 10px;
      font-size: 1.1em;
    }
    #resetBtn {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
    }
  </style>
</head>
<body>
  <h2>Pick as Many Dots as You Can (No Two Slopes the Same)</h2>

  <!-- ─────────── CONTROLS: Grid‐Size Selector and Reset Button ─────────── -->
  <div id="controls">
    <label for="gridSizeSelect">Grid Size:&nbsp;</label>
    <select id="gridSizeSelect">
      <!-- You can add or remove sizes as you like -->
      <option value="3">3 × 3</option>
      <option value="4">4 × 4</option>
      <option value="5" selected>5 × 5</option>
      <option value="6">6 × 6</option>
      <option value="7">7 × 7</option>
      <option value="8">8 × 8</option>
      <option value="9">9 × 9</option>
      <option value="10">10 × 10</option>
    </select>
    &nbsp;&nbsp;
    <button id="resetBtn">Start / Reset</button>
  </div>

  <!-- Canvas for drawing the grid -->
  <canvas id="gameCanvas" width="500" height="500"></canvas>

  <!-- Info area: how many selected vs. theoretical maximum -->
  <div id="info">
    Selected: <span id="count">0</span> /
    <span id="maxPossible">?</span> dots
  </div>

  <script>
    // ─────────── 1) GLOBAL STATE VARIABLES ───────────
    let gridSize = 5;         // current N (will be overwritten by selector)
    let canvasSize = 500;     // canvas is 500×500 px
    let margin = 40;          // px padding around the grid
    let dotRadius = 8;        // px radius of each dot
    let cellSize;             // computed: (canvasSize−2*margin)/(gridSize−1)

    let gridCoords = [];      // 2D array: gridCoords[i][j] = {x, y}
    let selected = [];        // list of {i,j} which are currently chosen
    let usedSlopes = new Set();// set of slope-strings in reduced form

    // Canvas context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Info spans
    const countSpan = document.getElementById('count');
    const maxSpan = document.getElementById('maxPossible');

    // Controls
    const gridSizeSelect = document.getElementById('gridSizeSelect');
    const resetBtn = document.getElementById('resetBtn');

    // ─────────── 2) UTILITY FUNCTIONS ───────────

    // Compute greatest common divisor
    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a;
    }

    // Given two grid‐indices (i1,j1) → (i2,j2), return reduced slope as a string.
    // dx = (j2–j1), dy = (i1–i2) (row difference is inverted because y‐axis points down in canvas).
    // If dx==0, return "inf". Otherwise return "dy/dx" in lowest terms with dx>0.
    function computeSlope(i1, j1, i2, j2) {
      const dx = j2 - j1;
      const dy = i1 - i2;
      if (dx === 0) {
        return 'inf';
      }
      let g = gcd(dy, dx);
      let rDy = dy / g;
      let rDx = dx / g;
      // Force rDx>0
      if (rDx < 0) {
        rDx = -rDx;
        rDy = -rDy;
      }
      return `${rDy}/${rDx}`;
    }

    // Update the displayed "Selected: X / Y" text
    function updateInfo() {
      countSpan.textContent = selected.length;
      maxSpan.textContent = gridSize + 1;
    }

    // Clear canvas, draw all dots, then draw selected in a different style
    function drawAll() {
      ctx.clearRect(0, 0, canvasSize, canvasSize);
      drawGrid();
      drawSelected();
    }

    // Draw all unselected dots in gray
    function drawGrid() {
      ctx.fillStyle = '#555';
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const { x, y } = gridCoords[i][j];
          ctx.beginPath();
          ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Draw selected dots in blue
    function drawSelected() {
      ctx.fillStyle = '#0b72b9';
      for (let { i, j } of selected) {
        const { x, y } = gridCoords[i][j];
        ctx.beginPath();
        ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Blink a dot in red if the click would cause a slope conflict
    function blinkInvalid(i, j) {
      const { x, y } = gridCoords[i][j];
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(x, y, dotRadius + 2, 0, Math.PI * 2);
      ctx.fill();
      setTimeout(() => {
        drawAll();
      }, 150);
    }

    // Remove a selected dot (i,j) and recompute all usedSlopes from scratch
    function removeSelection(i, j) {
      // Find index in 'selected'
      const idx = selected.findIndex(pt => pt.i === i && pt.j === j);
      if (idx === -1) return;
      selected.splice(idx, 1);
      // Rebuild usedSlopes
      usedSlopes.clear();
      for (let a = 0; a < selected.length; a++) {
        for (let b = a + 1; b < selected.length; b++) {
          const A = selected[a], B = selected[b];
          usedSlopes.add(computeSlope(A.i, A.j, B.i, B.j));
        }
      }
    }

    // Check if we can add (i,j) without repeating any slope
    function canAdd(i, j) {
      for (let { i: ii, j: jj } of selected) {
        const s = computeSlope(ii, jj, i, j);
        if (usedSlopes.has(s)) {
          return false;
        }
      }
      return true;
    }


    // ─────────── 3) INITIALIZATION ROUTINE ───────────
    function initGame() {
      // 1) Read the gridSize from the dropdown
      gridSize = parseInt(gridSizeSelect.value, 10);

      // 2) Compute cellSize so dots span from margin to canvasSize-margin
      cellSize = (canvasSize - 2 * margin) / (gridSize - 1);

      // 3) Build gridCoords[i][j] = { x, y } in canvas space
      gridCoords = new Array(gridSize);
      for (let i = 0; i < gridSize; i++) {
        gridCoords[i] = new Array(gridSize);
        for (let j = 0; j < gridSize; j++) {
          gridCoords[i][j] = {
            x: margin + j * cellSize,
            y: margin + i * cellSize
          };
        }
      }

      // 4) Clear any previous selections and usedSlopes
      selected = [];
      usedSlopes.clear();

      // 5) Update info text and draw for the very first time
      updateInfo();
      drawAll();
    }


    // ─────────── 4) CANVAS CLICK HANDLER ───────────
    canvas.addEventListener('click', (evt) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = evt.clientX - rect.left;
      const clickY = evt.clientY - rect.top;

      // Find which dot (i,j) is within radius of the click
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const { x, y } = gridCoords[i][j];
          const dist = Math.hypot(clickX - x, clickY - y);
          if (dist <= dotRadius + 3) {
            // User clicked near (i,j)
            // If already selected, deselect it
            const idx = selected.findIndex(pt => pt.i === i && pt.j === j);
            if (idx !== -1) {
              removeSelection(i, j);
              updateInfo();
              drawAll();
              return;
            }

            // Otherwise, try to add it
            if (!canAdd(i, j)) {
              blinkInvalid(i, j);
            } else {
              // Compute new slopes to add
              const newSlopes = [];
              for (let { i: ii, j: jj } of selected) {
                newSlopes.push(computeSlope(ii, jj, i, j));
              }
              // Add to selected and usedSlopes
              selected.push({ i, j });
              for (let s of newSlopes) {
                usedSlopes.add(s);
              }
              updateInfo();
              drawAll();
            }
            return;
          }
        }
      }
    });


    // ─────────── 5) HOOK UP CONTROLS ───────────
    // Reset/Start button: reinitialize with the currently chosen gridSize
    resetBtn.addEventListener('click', () => {
      initGame();
    });

    // Also, if the user changes the dropdown and then clicks elsewhere,
    // you might want to auto‐reset.  We'll do it on change:
    gridSizeSelect.addEventListener('change', () => {
      initGame();
    });

    // On page load, call initGame() once to set up the default state
    window.addEventListener('load', () => {
      initGame();
    });
  </script>
</body>
</html>

